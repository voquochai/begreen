{"version":3,"sources":["../../../js/stringProcessing/getSubheadingTexts.js"],"names":["module","exports","text","replace","subheadings","split","shift"],"mappings":"AAAA;AACA;;;;;;AAKAA,OAAOC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAC7B;;;;;;;AAOAA,SAAOA,KAAKC,OAAL,CAAa,MAAb,EAAqB,EAArB,CAAP;AACAD,SAAOA,KAAKC,OAAL,CAAa,oCAAb,EAAmD,GAAnD,CAAP;AACA,MAAIC,cAAcF,KAAKG,KAAL,CAAW,GAAX,CAAlB;AACA;;;;AAIAD,cAAYE,KAAZ;AACA,SAAOF,WAAP;AACH,CAjBD;AAkBA","file":"getSubheadingTexts.js","sourcesContent":["\"use strict\";\n/**\n * Returns all texts per subheading.\n * @param {string} text The text to analyze from.\n * @returns {Array} an array with text blocks per subheading.\n */\nmodule.exports = function (text) {\n    /*\n     Matching this in a regex is pretty hard, since we need to find a way for matching the text after a heading, and before the end of the text.\n     The hard thing capturing this is with a capture, it captures the next subheading as well, so it skips the next part of the text,\n     since the subheading is already matched.\n     For now we use this method to be sure we capture the right blocks of text. We remove all | 's from text,\n     then replace all headings with a | and split on a |.\n     */\n    text = text.replace(/\\|/ig, \"\");\n    text = text.replace(/<h([1-6])(?:[^>]+)?>(.*?)<\\/h\\1>/ig, \"|\");\n    var subheadings = text.split(\"|\");\n    /*\n     * We never need the first entry, if the text starts with a subheading it will be empty, and if the text doesn't start with a subheading,\n     * the text doesnt't belong to a subheading, so it can be removed\n     */\n    subheadings.shift();\n    return subheadings;\n};\n//# sourceMappingURL=getSubheadingTexts.js.map"]}