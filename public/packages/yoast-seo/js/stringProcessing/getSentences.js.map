{"version":3,"sources":["../../../js/stringProcessing/getSentences.js"],"names":["map","require","isUndefined","forEach","isNaN","filter","flatMap","isEmpty","negate","memoize","core","getBlocks","normalizeQuotes","normalize","unifyWhitespace","unifyNonBreakingSpace","fullStop","sentenceDelimiters","newLines","fullStopRegex","RegExp","sentenceDelimiterRegex","sentenceRegex","htmlStartRegex","htmlEndRegex","newLineRegex","blockStartRegex","blockEndRegex","tokens","sentenceTokenizer","createTokenizer","token","push","addRule","isCapitalLetter","character","toLocaleLowerCase","isNumber","parseInt","isBreakTag","htmlTag","test","isQuotation","isPunctuation","tokenizeSentences","text","onText","end","removeDuplicateWhitespace","replace","getNextTwoCharacters","nextTokens","next","src","isValidSentenceBeginning","sentenceBeginning","isSentenceStart","type","getSentencesFromTokens","tokenSentences","currentSentence","nextSentenceStart","sliced","firstToken","lastToken","length","slice","i","hasNextSentence","nextToken","secondToNextToken","nextCharacters","sentence","trim","getSentencesFromBlock","block","getSentencesFromBlockCached","module","exports","sentences","blocks","split"],"mappings":"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","file":"getSentences.js","sourcesContent":["\"use strict\";\nvar map = require(\"lodash/map\");\nvar isUndefined = require(\"lodash/isUndefined\");\nvar forEach = require(\"lodash/forEach\");\nvar isNaN = require(\"lodash/isNaN\");\nvar filter = require(\"lodash/filter\");\nvar flatMap = require(\"lodash/flatMap\");\nvar isEmpty = require(\"lodash/isEmpty\");\nvar negate = require(\"lodash/negate\");\nvar memoize = require(\"lodash/memoize\");\nvar core = require(\"tokenizer2/core\");\nvar getBlocks = require(\"../helpers/html.js\").getBlocks;\nvar normalizeQuotes = require(\"../stringProcessing/quotes.js\").normalize;\nvar unifyWhitespace = require(\"../stringProcessing/unifyWhitespace.js\").unifyNonBreakingSpace;\n// All characters that indicate a sentence delimiter.\nvar fullStop = \".\";\n// The \\u2026 character is an ellipsis\nvar sentenceDelimiters = \"?!;\\u2026\";\nvar newLines = \"\\n\\r|\\n|\\r\";\nvar fullStopRegex = new RegExp(\"^[\" + fullStop + \"]$\");\nvar sentenceDelimiterRegex = new RegExp(\"^[\" + sentenceDelimiters + \"]$\");\nvar sentenceRegex = new RegExp(\"^[^\" + fullStop + sentenceDelimiters + \"<\\\\(\\\\)\\\\[\\\\]]+$\");\nvar htmlStartRegex = /^<([^>\\s\\/]+)[^>]*>$/mi;\nvar htmlEndRegex = /^<\\/([^>\\s]+)[^>]*>$/mi;\nvar newLineRegex = new RegExp(newLines);\nvar blockStartRegex = /^\\s*[\\[\\(\\{]\\s*$/;\nvar blockEndRegex = /^\\s*[\\]\\)}]\\s*$/;\nvar tokens = [];\nvar sentenceTokenizer;\n/**\n * Creates a tokenizer to create tokens from a sentence.\n *\n * @returns {void}\n */\nfunction createTokenizer() {\n    tokens = [];\n    sentenceTokenizer = core(function (token) {\n        tokens.push(token);\n    });\n    sentenceTokenizer.addRule(htmlStartRegex, \"html-start\");\n    sentenceTokenizer.addRule(htmlEndRegex, \"html-end\");\n    sentenceTokenizer.addRule(blockStartRegex, \"block-start\");\n    sentenceTokenizer.addRule(blockEndRegex, \"block-end\");\n    sentenceTokenizer.addRule(fullStopRegex, \"full-stop\");\n    sentenceTokenizer.addRule(sentenceDelimiterRegex, \"sentence-delimiter\");\n    sentenceTokenizer.addRule(sentenceRegex, \"sentence\");\n}\n/**\n * Returns whether or not a certain character is a capital letter.\n *\n * @param {string} character The character to check.\n * @returns {boolean} Whether or not the character is a capital letter.\n */\nfunction isCapitalLetter(character) {\n    return character !== character.toLocaleLowerCase();\n}\n/**\n * Returns whether or not a certain character is a number.\n *\n * @param {string} character The character to check.\n * @returns {boolean} Whether or not the character is a capital letter.\n */\nfunction isNumber(character) {\n    return !isNaN(parseInt(character, 10));\n}\n/**\n * Returns whether or not a given HTML tag is a break tag.\n *\n * @param {string} htmlTag The HTML tag to check.\n * @returns {boolean} Whether or not the given HTML tag is a break tag.\n */\nfunction isBreakTag(htmlTag) {\n    return /<br/.test(htmlTag);\n}\n/**\n * Returns whether or not a given character is quotation mark.\n *\n * @param {string} character The character to check.\n * @returns {boolean} Whether or not the given character is a quotation mark.\n */\nfunction isQuotation(character) {\n    character = normalizeQuotes(character);\n    return \"'\" === character ||\n        \"\\\"\" === character;\n}\n/**\n * Returns whether or not a given character is a punctuation mark that can be at the beginning\n * of a sentence, like ¿ and ¡ used in Spanish.\n *\n * @param {string} character The character to check.\n * @returns {boolean} Whether or not the given character is a punctuation mark.\n */\nfunction isPunctuation(character) {\n    return \"¿\" === character ||\n        \"¡\" === character;\n}\n/**\n * Tokenizes a sentence, assumes that the text has already been split into blocks.\n *\n * @param {string} text The text to tokenize.\n * @returns {Array} An array of tokens.\n */\nfunction tokenizeSentences(text) {\n    createTokenizer();\n    sentenceTokenizer.onText(text);\n    sentenceTokenizer.end();\n    return tokens;\n}\n/**\n * Removes duplicate whitespace from a given text.\n *\n * @param {string} text The text with duplicate whitespace.\n * @returns {string} The text without duplicate whitespace.\n */\nfunction removeDuplicateWhitespace(text) {\n    return text.replace(/\\s+/, \" \");\n}\n/**\n * Retrieves the next two characters from an array with the two next tokens.\n *\n * @param {Array} nextTokens The two next tokens. Might be undefined.\n * @returns {string} The next two characters.\n */\nfunction getNextTwoCharacters(nextTokens) {\n    var next = \"\";\n    if (!isUndefined(nextTokens[0])) {\n        next += nextTokens[0].src;\n    }\n    if (!isUndefined(nextTokens[1])) {\n        next += nextTokens[1].src;\n    }\n    next = removeDuplicateWhitespace(next);\n    return next;\n}\n/**\n * Checks if the sentenceBeginning beginning is a valid beginning.\n *\n * @param {string} sentenceBeginning The beginning of the sentence to validate.\n * @returns {boolean} Returns true if it is a valid beginning, false if it is not.\n */\nfunction isValidSentenceBeginning(sentenceBeginning) {\n    return (isCapitalLetter(sentenceBeginning) ||\n        isNumber(sentenceBeginning) ||\n        isQuotation(sentenceBeginning) ||\n        isPunctuation(sentenceBeginning));\n}\n/**\n * Checks if the token is a valid sentence ending.\n *\n * @param {Object} token The token to validate.\n * @returns {boolean} Returns true if the token is valid ending, false if it is not.\n */\nfunction isSentenceStart(token) {\n    return (!isUndefined(token) && (\"html-start\" === token.type ||\n        \"html-end\" === token.type ||\n        \"block-start\" === token.type));\n}\n/**\n * Returns an array of sentences for a given array of tokens, assumes that the text has already been split into blocks.\n *\n * @param {Array} tokens The tokens from the sentence tokenizer.\n * @returns {Array<string>} A list of sentences.\n */\nfunction getSentencesFromTokens(tokens) {\n    var tokenSentences = [], currentSentence = \"\", nextSentenceStart;\n    var sliced;\n    // Drop the first and last HTML tag if both are present.\n    do {\n        sliced = false;\n        var firstToken = tokens[0];\n        var lastToken = tokens[tokens.length - 1];\n        if (firstToken.type === \"html-start\" && lastToken.type === \"html-end\") {\n            tokens = tokens.slice(1, tokens.length - 1);\n            sliced = true;\n        }\n    } while (sliced && tokens.length > 1);\n    forEach(tokens, function (token, i) {\n        var hasNextSentence;\n        var nextToken = tokens[i + 1];\n        var secondToNextToken = tokens[i + 2];\n        var nextCharacters;\n        switch (token.type) {\n            case \"html-start\":\n            case \"html-end\":\n                if (isBreakTag(token.src)) {\n                    tokenSentences.push(currentSentence);\n                    currentSentence = \"\";\n                }\n                else {\n                    currentSentence += token.src;\n                }\n                break;\n            case \"sentence\":\n                currentSentence += token.src;\n                break;\n            case \"sentence-delimiter\":\n                currentSentence += token.src;\n                if (!isUndefined(nextToken) && \"block-end\" !== nextToken.type) {\n                    tokenSentences.push(currentSentence);\n                    currentSentence = \"\";\n                }\n                break;\n            case \"full-stop\":\n                currentSentence += token.src;\n                nextCharacters = getNextTwoCharacters([nextToken, secondToNextToken]);\n                // For a new sentence we need to check the next two characters.\n                hasNextSentence = nextCharacters.length >= 2;\n                nextSentenceStart = hasNextSentence ? nextCharacters[1] : \"\";\n                // If the next character is a number, never split. For example: IPv4-numbers.\n                if (hasNextSentence && isNumber(nextCharacters[0])) {\n                    break;\n                }\n                // Only split on sentence delimiters when the next sentence looks like the start of a sentence.\n                if ((hasNextSentence && isValidSentenceBeginning(nextSentenceStart)) || isSentenceStart(nextToken)) {\n                    tokenSentences.push(currentSentence);\n                    currentSentence = \"\";\n                }\n                break;\n            case \"block-start\":\n                currentSentence += token.src;\n                break;\n            case \"block-end\":\n                currentSentence += token.src;\n                nextCharacters = getNextTwoCharacters([nextToken, secondToNextToken]);\n                // For a new sentence we need to check the next two characters.\n                hasNextSentence = nextCharacters.length >= 2;\n                nextSentenceStart = hasNextSentence ? nextCharacters[0] : \"\";\n                // If the next character is a number, never split. For example: IPv4-numbers.\n                if (hasNextSentence && isNumber(nextCharacters[0])) {\n                    break;\n                }\n                if ((hasNextSentence && isValidSentenceBeginning(nextSentenceStart)) || isSentenceStart(nextToken)) {\n                    tokenSentences.push(currentSentence);\n                    currentSentence = \"\";\n                }\n                break;\n        }\n    });\n    if (\"\" !== currentSentence) {\n        tokenSentences.push(currentSentence);\n    }\n    tokenSentences = map(tokenSentences, function (sentence) {\n        return sentence.trim();\n    });\n    return tokenSentences;\n}\n/**\n * Returns the sentences from a certain block.\n *\n * @param {string} block The HTML inside a HTML block.\n * @returns {Array<string>} The list of sentences in the block.\n */\nfunction getSentencesFromBlock(block) {\n    var tokens = tokenizeSentences(block);\n    return tokens.length === 0 ? [] : getSentencesFromTokens(tokens);\n}\nvar getSentencesFromBlockCached = memoize(getSentencesFromBlock);\n/**\n * Returns sentences in a string.\n *\n * @param {String} text The string to count sentences in.\n * @returns {Array} Sentences found in the text.\n */\nmodule.exports = function (text) {\n    text = unifyWhitespace(text);\n    var sentences, blocks = getBlocks(text);\n    // Split each block on newlines.\n    blocks = flatMap(blocks, function (block) {\n        return block.split(newLineRegex);\n    });\n    sentences = flatMap(blocks, getSentencesFromBlockCached);\n    return filter(sentences, negate(isEmpty));\n};\n//# sourceMappingURL=getSentences.js.map"]}