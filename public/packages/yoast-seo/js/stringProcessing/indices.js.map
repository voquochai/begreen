{"version":3,"sources":["../../../js/stringProcessing/indices.js"],"names":["isUndefined","require","forEach","stripSpaces","matchWordInSentence","isWordInSentence","characterInBoundary","getIndicesByWord","word","text","startIndex","searchStringLength","length","index","indices","indexOf","isPreviousCharacterWordBoundary","isNextCharacterWordBoundary","push","match","getIndicesByWordList","words","matchedWords","concat","sortIndices","sort","a","b","filterIndices","filtered","i","module","exports"],"mappings":"AAAA;;AACA,IAAIA,cAAcC,QAAQ,oBAAR,CAAlB;AACA,IAAIC,UAAUD,QAAQ,gBAAR,CAAd;AACA,IAAIE,cAAcF,QAAQ,oCAAR,CAAlB;AACA,IAAIG,sBAAsBH,QAAQ,4CAAR,EAAsDI,gBAAhF;AACA,IAAIC,sBAAsBL,QAAQ,4CAAR,EAAsDK,mBAAhF;AACA;;;;;;;AAOA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAhC,EAAsC;AAClC,QAAIC,aAAa,CAAjB;AACA,QAAIC,qBAAqBH,KAAKI,MAA9B;AACA,QAAIC,KAAJ;AAAA,QAAWC,UAAU,EAArB;AACA,WAAO,CAACD,QAAQJ,KAAKM,OAAL,CAAaP,IAAb,EAAmBE,UAAnB,CAAT,IAA2C,CAAC,CAAnD,EAAsD;AAClD;AACA,YAAIM,kCAAkCV,oBAAoBG,KAAKI,QAAQ,CAAb,CAApB,KAAwCA,UAAU,CAAxF;AACA,YAAII,8BAA8BX,oBAAoBG,KAAKI,QAAQF,kBAAb,CAApB,KAA0DF,KAAKG,MAAL,KAAgBC,QAAQF,kBAApH;AACA,YAAIK,mCAAmCC,2BAAvC,EAAoE;AAChEH,oBAAQI,IAAR,CAAa;AACTL,uBAAOA,KADE;AAETM,uBAAOX;AAFE,aAAb;AAIH;AACDE,qBAAaG,QAAQF,kBAArB;AACH;AACD,WAAOG,OAAP;AACH;AACD;;;;;;;;AAQA,IAAIM,uBAAuB,SAAvBA,oBAAuB,CAAUC,KAAV,EAAiBZ,IAAjB,EAAuB;AAC9C,QAAIa,eAAe,EAAnB;AACApB,YAAQmB,KAAR,EAAe,UAAUb,IAAV,EAAgB;AAC3BA,eAAOL,YAAYK,IAAZ,CAAP;AACA,YAAI,CAACJ,oBAAoBI,IAApB,EAA0BC,IAA1B,CAAL,EAAsC;AAClC;AACH;AACDa,uBAAeA,aAAaC,MAAb,CAAoBhB,iBAAiBC,IAAjB,EAAuBC,IAAvB,CAApB,CAAf;AACH,KAND;AAOA,WAAOa,YAAP;AACH,CAVD;AAWA;;;;;;AAMA,IAAIE,cAAc,SAAdA,WAAc,CAAUV,OAAV,EAAmB;AACjC,WAAOA,QAAQW,IAAR,CAAa,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChC,eAAQD,EAAEb,KAAF,GAAUc,EAAEd,KAApB;AACH,KAFM,CAAP;AAGH,CAJD;AAKA;;;;;;AAMA,IAAIe,gBAAgB,SAAhBA,aAAgB,CAAUd,OAAV,EAAmB;AACnCA,cAAUU,YAAYV,OAAZ,CAAV;AACA,QAAIe,WAAW,EAAf;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIhB,QAAQF,MAA5B,EAAoCkB,GAApC,EAAyC;AACrC;AACA;AACA,YAAI,CAAC9B,YAAYc,QAAQgB,IAAI,CAAZ,CAAZ,CAAD,IAAgChB,QAAQgB,IAAI,CAAZ,EAAejB,KAAf,GAAuBC,QAAQgB,CAAR,EAAWjB,KAAX,GAAmBC,QAAQgB,CAAR,EAAWX,KAAX,CAAiBP,MAA/F,EAAuG;AACnGiB,qBAASX,IAAT,CAAcJ,QAAQgB,CAAR,CAAd;AACA;AACAA;AACA;AACH;AACDD,iBAASX,IAAT,CAAcJ,QAAQgB,CAAR,CAAd;AACH;AACD,WAAOD,QAAP;AACH,CAfD;AAgBAE,OAAOC,OAAP,GAAiB;AACbzB,sBAAkBA,gBADL;AAEba,0BAAsBA,oBAFT;AAGbQ,mBAAeA,aAHF;AAIbJ,iBAAaA;AAJA,CAAjB;AAMA","file":"indices.js","sourcesContent":["\"use strict\";\nvar isUndefined = require(\"lodash/isUndefined\");\nvar forEach = require(\"lodash/forEach\");\nvar stripSpaces = require(\"../stringProcessing/stripSpaces.js\");\nvar matchWordInSentence = require(\"../stringProcessing/matchWordInSentence.js\").isWordInSentence;\nvar characterInBoundary = require(\"../stringProcessing/matchWordInSentence.js\").characterInBoundary;\n/**\n * Returns the indices of a string in a text. If it is found multiple times, it will return multiple indices.\n *\n * @param {string} word The word to find in the text.\n * @param {string} text The text to check for the given word.\n * @returns {Array} All indices found.\n */\nfunction getIndicesByWord(word, text) {\n    var startIndex = 0;\n    var searchStringLength = word.length;\n    var index, indices = [];\n    while ((index = text.indexOf(word, startIndex)) > -1) {\n        // Check if the previous and next character are word boundaries to determine if a complete word was detected\n        var isPreviousCharacterWordBoundary = characterInBoundary(text[index - 1]) || index === 0;\n        var isNextCharacterWordBoundary = characterInBoundary(text[index + searchStringLength]) || (text.length === index + searchStringLength);\n        if (isPreviousCharacterWordBoundary && isNextCharacterWordBoundary) {\n            indices.push({\n                index: index,\n                match: word,\n            });\n        }\n        startIndex = index + searchStringLength;\n    }\n    return indices;\n}\n/**\n * Matches string with an array, returns the word and the index it was found on.\n *\n * @param {Array} words The array with strings to match.\n * @param {string} text The text to match the strings from the array to.\n * @returns {Array} The array with words, containing the index of the match and the matched string.\n * Returns an empty array if none are found.\n */\nvar getIndicesByWordList = function (words, text) {\n    var matchedWords = [];\n    forEach(words, function (word) {\n        word = stripSpaces(word);\n        if (!matchWordInSentence(word, text)) {\n            return;\n        }\n        matchedWords = matchedWords.concat(getIndicesByWord(word, text));\n    });\n    return matchedWords;\n};\n/**\n * Sorts the array on the index property of each entry.\n *\n * @param {Array} indices The array with indices.\n * @returns {Array} The sorted array with indices.\n */\nvar sortIndices = function (indices) {\n    return indices.sort(function (a, b) {\n        return (a.index > b.index);\n    });\n};\n/**\n * Filters duplicate entries if the indices overlap.\n *\n * @param {Array} indices The array with indices to be filtered.\n * @returns {Array} The filtered array.\n */\nvar filterIndices = function (indices) {\n    indices = sortIndices(indices);\n    var filtered = [];\n    for (var i = 0; i < indices.length; i++) {\n        // If the next index is within the range of the current index and the length of the word, remove it\n        // This makes sure we don't match combinations twice, like \"even though\" and \"though\".\n        if (!isUndefined(indices[i + 1]) && indices[i + 1].index < indices[i].index + indices[i].match.length) {\n            filtered.push(indices[i]);\n            // Adds 1 to i, so we skip the next index that is overlapping with the current index.\n            i++;\n            continue;\n        }\n        filtered.push(indices[i]);\n    }\n    return filtered;\n};\nmodule.exports = {\n    getIndicesByWord: getIndicesByWord,\n    getIndicesByWordList: getIndicesByWordList,\n    filterIndices: filterIndices,\n    sortIndices: sortIndices,\n};\n//# sourceMappingURL=indices.js.map"]}