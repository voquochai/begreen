{"version":3,"sources":["../../../../js/stringProcessing/syllables/DeviationFragment.js"],"names":["isUndefined","require","pick","DeviationFragment","options","_location","location","_fragment","word","_syllables","syllables","_regex","_options","prototype","createRegex","regexString","fragment","notFollowedBy","join","alsoFollowedBy","RegExp","getRegex","occursIn","regex","test","removeFrom","replace","getSyllables","module","exports"],"mappings":"AAAA;;AACA,IAAIA,cAAcC,QAAQ,oBAAR,CAAlB;AACA,IAAIC,OAAOD,QAAQ,aAAR,CAAX;AACA;;;;;;;;;;;;AAYA,SAASE,iBAAT,CAA2BC,OAA3B,EAAoC;AAChC,SAAKC,SAAL,GAAiBD,QAAQE,QAAzB;AACA,SAAKC,SAAL,GAAiBH,QAAQI,IAAzB;AACA,SAAKC,UAAL,GAAkBL,QAAQM,SAA1B;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,QAAL,GAAgBV,KAAKE,OAAL,EAAc,CAAC,eAAD,EAAkB,gBAAlB,CAAd,CAAhB;AACH;AACD;;;;;AAKAD,kBAAkBU,SAAlB,CAA4BC,WAA5B,GAA0C,YAAY;AAClD,QAAIC,cAAc,EAAlB;AACA,QAAIX,UAAU,KAAKQ,QAAnB;AACA,QAAII,WAAW,KAAKT,SAApB;AACA,QAAI,CAACP,YAAYI,QAAQa,aAApB,CAAL,EAAyC;AACrCD,oBAAY,SAASZ,QAAQa,aAAR,CAAsBC,IAAtB,CAA2B,EAA3B,CAAT,GAA0C,IAAtD;AACH;AACD,QAAI,CAAClB,YAAYI,QAAQe,cAApB,CAAL,EAA0C;AACtCH,oBAAY,MAAMZ,QAAQe,cAAR,CAAuBD,IAAvB,CAA4B,EAA5B,CAAN,GAAwC,IAApD;AACH;AACD,YAAQ,KAAKb,SAAb;AACI,aAAK,aAAL;AACIU,0BAAc,MAAMC,QAApB;AACA;AACJ,aAAK,OAAL;AACID,0BAAcC,WAAW,GAAzB;AACA;AACJ,aAAK,kBAAL;AACID,0BAAc,OAAOC,QAAP,GAAkB,KAAlB,GAA0BA,QAA1B,GAAqC,IAAnD;AACA;AACJ;AACID,0BAAcC,QAAd;AACA;AAZR;AAcA,SAAKL,MAAL,GAAc,IAAIS,MAAJ,CAAWL,WAAX,CAAd;AACH,CAzBD;AA0BA;;;;;AAKAZ,kBAAkBU,SAAlB,CAA4BQ,QAA5B,GAAuC,YAAY;AAC/C,QAAI,SAAS,KAAKV,MAAlB,EAA0B;AACtB,aAAKG,WAAL;AACH;AACD,WAAO,KAAKH,MAAZ;AACH,CALD;AAMA;;;;;;AAMAR,kBAAkBU,SAAlB,CAA4BS,QAA5B,GAAuC,UAAUd,IAAV,EAAgB;AACnD,QAAIe,QAAQ,KAAKF,QAAL,EAAZ;AACA,WAAOE,MAAMC,IAAN,CAAWhB,IAAX,CAAP;AACH,CAHD;AAIA;;;;;;AAMAL,kBAAkBU,SAAlB,CAA4BY,UAA5B,GAAyC,UAAUjB,IAAV,EAAgB;AACrD;AACA,WAAOA,KAAKkB,OAAL,CAAa,KAAKnB,SAAlB,EAA6B,GAA7B,CAAP;AACH,CAHD;AAIA;;;;;AAKAJ,kBAAkBU,SAAlB,CAA4Bc,YAA5B,GAA2C,YAAY;AACnD,WAAO,KAAKlB,UAAZ;AACH,CAFD;AAGAmB,OAAOC,OAAP,GAAiB1B,iBAAjB;AACA","file":"DeviationFragment.js","sourcesContent":["\"use strict\";\nvar isUndefined = require(\"lodash/isUndefined\");\nvar pick = require(\"lodash/pick\");\n/**\n * Represents a partial deviation when counting syllables\n *\n * @param {Object} options Extra options about how to match this fragment.\n * @param {string} options.location The location in the word where this deviation can occur.\n * @param {string} options.word The actual string that should be counted differently.\n * @param {number} options.syllables The amount of syllables this fragment has.\n * @param {string[]} [options.notFollowedBy] A list of characters that this fragment shouldn't be followed with.\n * @param {string[]} [options.alsoFollowedBy] A list of characters that this fragment could be followed with.\n *\n * @constructor\n */\nfunction DeviationFragment(options) {\n    this._location = options.location;\n    this._fragment = options.word;\n    this._syllables = options.syllables;\n    this._regex = null;\n    this._options = pick(options, [\"notFollowedBy\", \"alsoFollowedBy\"]);\n}\n/**\n * Creates a regex that matches this fragment inside a word.\n *\n * @returns {void}\n */\nDeviationFragment.prototype.createRegex = function () {\n    var regexString = \"\";\n    var options = this._options;\n    var fragment = this._fragment;\n    if (!isUndefined(options.notFollowedBy)) {\n        fragment += \"(?![\" + options.notFollowedBy.join(\"\") + \"])\";\n    }\n    if (!isUndefined(options.alsoFollowedBy)) {\n        fragment += \"[\" + options.alsoFollowedBy.join(\"\") + \"]?\";\n    }\n    switch (this._location) {\n        case \"atBeginning\":\n            regexString = \"^\" + fragment;\n            break;\n        case \"atEnd\":\n            regexString = fragment + \"$\";\n            break;\n        case \"atBeginningOrEnd\":\n            regexString = \"(^\" + fragment + \")|(\" + fragment + \"$)\";\n            break;\n        default:\n            regexString = fragment;\n            break;\n    }\n    this._regex = new RegExp(regexString);\n};\n/**\n * Returns the regex that matches this fragment inside a word.\n *\n * @returns {RegExp} The regexp that matches this fragment.\n */\nDeviationFragment.prototype.getRegex = function () {\n    if (null === this._regex) {\n        this.createRegex();\n    }\n    return this._regex;\n};\n/**\n * Returns whether or not this fragment occurs in a word.\n *\n * @param {string} word The word to match the fragment in.\n * @returns {boolean} Whether or not this fragment occurs in a word.\n */\nDeviationFragment.prototype.occursIn = function (word) {\n    var regex = this.getRegex();\n    return regex.test(word);\n};\n/**\n * Removes this fragment from the given word.\n *\n * @param {string} word The word to remove this fragment from.\n * @returns {string} The modified word.\n */\nDeviationFragment.prototype.removeFrom = function (word) {\n    // Replace by a space to keep the remaining parts separated.\n    return word.replace(this._fragment, \" \");\n};\n/**\n * Returns the amount of syllables for this fragment.\n *\n * @returns {number} The amount of syllables for this fragment.\n */\nDeviationFragment.prototype.getSyllables = function () {\n    return this._syllables;\n};\nmodule.exports = DeviationFragment;\n//# sourceMappingURL=DeviationFragment.js.map"]}