{"version":3,"sources":["../../../js/stringProcessing/htmlParser.js"],"names":["htmlparser","require","includes","textArray","inScriptBlock","inlineTags","parser","Parser","onopentag","tagName","nodeValue","nodeValueType","Object","keys","nodeValueString","forEach","node","push","ontext","text","onclosetag","decodeEntities","module","exports","write","join"],"mappings":"AAAA;AACA;;AACA,IAAIA,aAAaC,QAAQ,aAAR,CAAjB;AACA,IAAIC,WAAWD,QAAQ,iBAAR,CAAf;AACA;AACA,IAAIE,kBAAJ;AACA;AACA,IAAIC,gBAAgB,KAApB;AACA;AACA,IAAIC,aAAa,CAAC,QAAD,EAAW,OAAX,EAAoB,MAApB,EAA4B,KAA5B,CAAjB;AACA;;;AAGA,IAAIC,SAAS,IAAIN,WAAWO,MAAf,CAAsB;AAC/B;;;;;;;;AAQAC,eAAW,mBAAUC,OAAV,EAAmBC,SAAnB,EAA8B;AACrC,YAAIR,SAASG,UAAT,EAAqBI,OAArB,CAAJ,EAAmC;AAC/BL,4BAAgB,IAAhB;AACA;AACH;AACD,YAAIO,gBAAgBC,OAAOC,IAAP,CAAYH,SAAZ,CAApB;AACA,YAAII,kBAAkB,EAAtB;AACAH,sBAAcI,OAAd,CAAsB,UAAUC,IAAV,EAAgB;AAClC;AACAF,+BAAmB,MAAME,IAAN,GAAa,IAAb,GAAoBN,UAAUM,IAAV,CAApB,GAAsC,GAAzD;AACH,SAHD;AAIAb,kBAAUc,IAAV,CAAe,MAAMR,OAAN,GAAgBK,eAAhB,GAAkC,GAAjD;AACH,KArB8B;AAsB/B;;;;;;;AAOAI,YAAQ,gBAAUC,IAAV,EAAgB;AACpB,YAAI,CAACf,aAAL,EAAoB;AAChBD,sBAAUc,IAAV,CAAeE,IAAf;AACH;AACJ,KAjC8B;AAkC/B;;;;;;;;AAQAC,gBAAY,oBAAUX,OAAV,EAAmB;AAC3B,YAAIP,SAASG,UAAT,EAAqBI,OAArB,CAAJ,EAAmC;AAC/BL,4BAAgB,KAAhB;AACA;AACH;AACDD,kBAAUc,IAAV,CAAe,OAAOR,OAAP,GAAiB,GAAhC;AACH;AAhD8B,CAAtB,EAiDV,EAAEY,gBAAgB,IAAlB,EAjDU,CAAb;AAkDA;;;;;;AAMAC,OAAOC,OAAP,GAAiB,UAAUJ,IAAV,EAAgB;AAC7BhB,gBAAY,EAAZ;AACAG,WAAOkB,KAAP,CAAaL,IAAb;AACA,WAAOhB,UAAUsB,IAAV,CAAe,EAAf,CAAP;AACH,CAJD;AAKA","file":"htmlParser.js","sourcesContent":["\"use strict\";\n// We use an external library, which can be found here: https://github.com/fb55/htmlparser2.\nlet htmlparser = require(\"htmlparser2\");\nlet includes = require(\"lodash/includes\");\n// The array containing the text parts without the blocks defined in inlineTags.\nlet textArray;\n// False when we are not in a block defined in inlineTags. True if we are.\nlet inScriptBlock = false;\n// The blocks we filter out of the text that needs to be parsed.\nlet inlineTags = [\"script\", \"style\", \"code\", \"pre\"];\n/**\n * Parses the text.\n */\nlet parser = new htmlparser.Parser({\n    /**\n     * Handles the opening tag. If the opening tag is included in the inlineTags array, set inScriptBlock to true.\n     * If the opening tag is not included in the inlineTags array, push the tag to the textArray.\n     *\n     * @param {string} tagName The tag name.\n     * @param {object} nodeValue The attribute with the keys and values of the tag.\n     * @returns {void}\n     */\n    onopentag: function (tagName, nodeValue) {\n        if (includes(inlineTags, tagName)) {\n            inScriptBlock = true;\n            return;\n        }\n        let nodeValueType = Object.keys(nodeValue);\n        let nodeValueString = \"\";\n        nodeValueType.forEach(function (node) {\n            // Build the tag again.\n            nodeValueString += \" \" + node + \"='\" + nodeValue[node] + \"'\";\n        });\n        textArray.push(\"<\" + tagName + nodeValueString + \">\");\n    },\n    /**\n     * Handles the text that doesn't contain opening or closing tags. If inScriptBlock is false, the text gets pushed to the textArray array.\n     *\n     * @param {string} text The text that doesn't contain opening or closing tags.\n     *\n     * @returns {void}\n     */\n    ontext: function (text) {\n        if (!inScriptBlock) {\n            textArray.push(text);\n        }\n    },\n    /**\n     * Handles the closing tag. If the closing tag is included in the inlineTags array, set inScriptBlock to false.\n     * If the closing tag is not included in the inlineTags array, push the tag to the textArray.\n     *\n     * @param {string} tagName The tag name.\n     *\n     * @returns {void}\n     */\n    onclosetag: function (tagName) {\n        if (includes(inlineTags, tagName)) {\n            inScriptBlock = false;\n            return;\n        }\n        textArray.push(\"</\" + tagName + \">\");\n    },\n}, { decodeEntities: true });\n/**\n * Calls the htmlparser and returns the text without the HTML blocks as defined in the inlineTags array.\n *\n * @param {string} text The text to parse.\n * @returns {string} The text without the HTML blocks as defined in the inlineTags array.\n */\nmodule.exports = function (text) {\n    textArray = [];\n    parser.write(text);\n    return textArray.join(\"\");\n};\n//# sourceMappingURL=htmlParser.js.map"]}